<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>核心功能測試</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1a1a1d;
            color: #e0e0e0;
        }

        #output {
            white-space: pre-wrap;
            background: #000;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .success {
            color: #4caf50;
        }

        .error {
            color: #f44336;
        }

        .info {
            color: #2196f3;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
        }

        button:hover {
            background: #45a049;
        }
    </style>
</head>

<body>
    <h1>遊戲核心功能測試</h1>
    <div>
        <button id="testResources">測試資源系統</button>
        <button id="testBuildings">測試建築系統</button>
        <button id="testManualGather">測試手動採集</button>
        <button id="testAutoGrow">測試自動增長</button>
        <button id="testLifespanReset">測試壽元已盡重置</button>
        <button id="testMaidSystem">測試侍女自動合成</button>
        <button id="testTrainingTime">測試修煉時間顯示</button>
        <button id="testHintSystem">測試提示系統狀態</button>
    </div>
    <div style="margin-top: 20px; padding: 10px; border: 1px solid #9c27b0; border-radius: 8px;">
        <h3 style="color: #ba68c8;">宗門系統測試</h3>
        <button id="sectCheckUnlock" style="background: #ba68c8;">1. 前往築基期 (解鎖測試)</button>
        <button id="sectAddRes" style="background: #9c27b0;">2. 添加貢獻資源</button>
        <button id="sectContribute" style="background: #7b1fa2;">3. 執行貢獻</button>
        <button id="sectMaxLevel" style="background: #ab47bc;">4. 宗門滿級 (LV5)</button>
        <button id="sectTaskTest" style="background: #8e24aa;">5. 任務流程測試 (刷新/接受/領取)</button>
    </div>
    <div style="margin-top: 20px; padding: 10px; border: 1px solid #444; border-radius: 8px;">
        <h3>存檔功能測試</h3>
        <button id="testSaveCode">生成存檔碼</button>
        <button id="testLoadCode">讀取存檔碼</button>
        <button id="testSaveStorage">保存至 Storage</button>
        <button id="testLoadStorage">從 Storage 讀取</button>
        <div style="margin-top: 10px;">
            <textarea id="saveCodeArea" style="width: 100%; background: #222; color: #fff; border: 1px solid #555;"
                rows="5" placeholder="在此處貼上存檔碼..."></textarea>
        </div>
    </div>
    <div id="output"></div>

    <script type="module">
        const output = document.getElementById('output');

        function log(msg, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const span = document.createElement('span');
            span.className = type;
            span.textContent = `[${time}] ${msg}\n`;
            output.appendChild(span);
            output.scrollTop = output.scrollHeight;
        }

        let resourceManager = null;
        let buildingManager = null;
        let SaveSystem = null;
        // Pre-define window.game as a fallback
        window.game = {
            resourceManager: null,
            buildingManager: null,
            uiManager: { addLog: (msg, type) => log(`[GameLog] ${msg}`, type || 'info') }
        };

        // 初始化
        async function init() {
            try {
                log('載入模組與 CSV 資料...', 'info');
                const { default: ResourceManager } = await import('./src/data/Resources.js');
                const { default: BuildingManager } = await import('./src/utils/BuildingManager.js');
                const { default: SaveSystemModule } = await import('./src/utils/saveSystem.js');
                SaveSystem = SaveSystemModule;
                const { loadBuildings } = await import('./src/data/Buildings.js');
                const { default: EraManager } = await import('./src/utils/EraManager.js');
                const { default: SkillManager } = await import('./src/utils/SkillManager.js');

                // 1. 資源初始化
                resourceManager = new ResourceManager();
                await resourceManager.init();

                // 2. 時代與功法初始化
                await EraManager.init();
                await SkillManager.init();

                // 3. 建築資料初始化
                await loadBuildings();
                buildingManager = new BuildingManager(resourceManager);
                buildingManager.init();

                // Mock window.game for modules that depend on it (like SectManager)
                // Update the pre-defined object properties instead of reassignment
                window.game.resourceManager = resourceManager;
                window.game.buildingManager = buildingManager;
                // uiManager is already set in pre-define.
                window.game.saveSystem = null; // Set later if needed

                log('✓ 模組載入成功', 'success');

                const lingli = resourceManager.getResource('lingli');
                const money = resourceManager.getResource('money');

                if (lingli && money) {
                    log(`靈力產率: ${lingli.rate}/秒`, 'info');
                    log(`金錢產率: ${money.rate}/秒`, 'info');
                } else {
                    log('✗ 無法讀取基礎資源數據', 'error');
                }

            } catch (e) {
                log(`✗ 初始化失敗: ${e.message}`, 'error');
                log(e.stack, 'error');
            }
        }

        // 測試資源系統
        document.getElementById('testResources').addEventListener('click', () => {
            if (!resourceManager) {
                log('✗ 資源管理器未初始化', 'error');
                return;
            }

            log('\n=== 測試資源系統 ===', 'info');
            const resources = resourceManager.getUnlockedResources();

            for (const [key, res] of Object.entries(resources)) {
                log(`${res.name}: 值=${res.value.toFixed(2)}, 最大=${res.max}, 產率=${res.rate}/秒, 類型=${res.type}`, 'info');
            }

            log('✓ 資源系統測試完成', 'success');
        });

        // 測試建築系統
        document.getElementById('testBuildings').addEventListener('click', () => {
            if (!buildingManager) {
                log('✗ 建築管理器未初始化', 'error');
                return;
            }

            log('\n=== 測試建築系統 ===', 'info');
            const buildings = buildingManager.exportData().buildings;

            for (const [key, building] of Object.entries(buildings)) {
                log(`${key}: 等級=${building.level}`, 'info');
            }

            log('✓ 建築系統測試完成', 'success');
        });

        // 測試手動採集
        document.getElementById('testManualGather').addEventListener('click', () => {
            if (!resourceManager) {
                log('✗ 資源管理器未初始化', 'error');
                return;
            }

            log('\n=== 測試手動採集 ===', 'info');

            const lingli = resourceManager.getResource('lingli');
            const before = lingli.value;

            log(`採集前靈力: ${before.toFixed(2)}`, 'info');

            const result = resourceManager.manualGather('lingli');
            const after = lingli.value;

            log(`採集結果: ${result ? '成功' : '失敗'}`, result ? 'success' : 'error');
            log(`採集後靈力: ${after.toFixed(2)}`, 'info');
            log(`增加量: ${(after - before).toFixed(2)}`, after > before ? 'success' : 'error');

            if (after > before) {
                log('✓ 手動採集功能正常', 'success');
            } else {
                log('✗ 手動採集功能異常', 'error');
            }
        });

        // 測試自動增長 (優化安全性：不再重置正式數據)
        document.getElementById('testAutoGrow').addEventListener('click', async () => {
            if (!resourceManager) {
                log('✗ 資源管理器未初始化', 'error');
                return;
            }

            log('\n=== 測試自動增長 ===', 'info');

            // 導入 PlayerManager
            const { default: PlayerManager } = await import('./src/utils/PlayerManager.js');

            // 備份原始狀態
            const originalState = JSON.parse(JSON.stringify(PlayerManager.state));
            const originalIsExhausted = PlayerManager.isLifespanExhausted;

            try {
                // 臨時模擬壽元狀態，防止測試過程中觸發重置邏輯
                // 直接修改實例方法，確保 ResourceManager 引用到的實例也能生效
                PlayerManager.isLifespanExhausted = () => {
                    // console.log('Mock isLifespanExhausted called -> false');
                    return false;
                };

                // 強制設定為時代1、等級1
                PlayerManager.state.eraId = 1;
                PlayerManager.state.level = 1;

                // 檢查必要狀態
                log(`ResourceManager Loaded: ${resourceManager.isLoaded}`, 'info');
                const lingli = resourceManager.getResource('lingli');
                if (!lingli) {
                    log('✗ 找不到靈力資源', 'error');
                    return;
                }

                // 強制解鎖並歸零
                lingli.unlocked = true;
                lingli.value = 0;

                log(`靈力狀態: Unlocked=${lingli.unlocked}, Value=${lingli.value}`, 'info');
                log(`PlayerManager: Era=${PlayerManager.getEraId()}, Level=${PlayerManager.getLevel()}`, 'info');
                log(`Lifespan Exhausted Check: ${PlayerManager.isLifespanExhausted()}`, 'info');

                const before = lingli.value;
                const baseRate = lingli.rate;

                const currentEra = PlayerManager.getEraId();
                const currentLevel = PlayerManager.getLevel();
                const lingliConsumption = (currentEra - 1) * 10 + currentLevel - 2;
                const netRate = baseRate - lingliConsumption;

                log(`測試前靈力: ${before.toFixed(2)}`, 'info');
                log(`靈力基礎產率: ${baseRate}/秒`, 'info');
                log(`靈力消耗: ${lingliConsumption}/秒 (Era${currentEra} Lv${currentLevel})`, 'info');
                log(`靈力淨產率: ${netRate.toFixed(2)}/秒`, 'info');

                // 模擬 5 秒更新
                log('執行 update(5)...', 'info');
                resourceManager.update(5);

                const after = lingli.value;
                const expected = netRate * 5;
                const actual = after - before;

                log(`5秒後靈力: ${after.toFixed(2)}`, 'info');
                log(`實際增加: ${actual.toFixed(2)}`, 'info');
                log(`預期增加: ${expected.toFixed(2)}`, 'info');

                if (Math.abs(actual - expected) < 0.01 && actual > 0) {
                    log('✓ 自動增長功能正常', 'success');
                } else {
                    log('✗ 自動增長功能異常', 'error');
                    log(`差異: ${Math.abs(actual - expected).toFixed(4)}`, 'error');
                }
            } catch (e) {
                log(`✗ 測試過程中出錯: ${e.message}`, 'error');
                console.error(e);
            } finally {
                // 恢復原始狀態與方法
                PlayerManager.state = originalState;
                PlayerManager.isLifespanExhausted = originalIsExhausted;
                log('✓ 已恢復 PlayerManager 原始狀態', 'info');
            }
        });

        // 測試壽元已盡重置
        document.getElementById('testLifespanReset').addEventListener('click', async () => {
            if (!resourceManager) {
                log('✗ 資源管理器未初始化', 'error');
                return;
            }

            log('\n=== 測試壽元已盡重置 ===', 'info');
            log('注意：此測試會模擬壽元已盡，並檢查時期進度是否重置', 'info');

            const { default: PlayerManager } = await import('./src/utils/PlayerManager.js');

            // 保存原始狀態與方法
            const originalState = JSON.parse(JSON.stringify(PlayerManager.state));
            const originalSave = PlayerManager._saveState;

            try {
                // 攔截儲存，防止影響正式數據
                PlayerManager._saveState = () => { /* 測試中不儲存 */ };

                // 模擬壽元已盡 (將 totalStartTimestamp 設為很久以前)
                const maxLifespanYears = PlayerManager.getMaxLifespan();
                const farPast = Date.now() - (maxLifespanYears + 1) * 60000;

                PlayerManager.state.totalStartTimestamp = farPast;
                PlayerManager.state.isReincarnating = false;
                const oldStartTimestamp = PlayerManager.state.startTimestamp;

                log(`模擬已過年歲: ${(Date.now() - farPast) / 60000} 年`, 'info');
                log(`壽元上限: ${maxLifespanYears} 年`, 'info');
                log(`是否已盡: ${PlayerManager.isLifespanExhausted()}`, 'info');
                log(`當前時期開始時間: ${oldStartTimestamp}`, 'info');

                // 觸發資源更新
                log('更新資源系統...', 'info');
                resourceManager.update(1);

                // 檢查結果
                const newStartTimestamp = PlayerManager.state.startTimestamp;
                const isReinc = PlayerManager.state.isReincarnating;

                log(`重置後時期開始時間: ${newStartTimestamp}`, 'info');
                log(`輪迴狀態標記: ${isReinc}`, 'info');

                if (newStartTimestamp > oldStartTimestamp && isReinc === true) {
                    log('✓ 壽元已盡重置功能正常', 'success');
                } else {
                    log('✗ 壽元已盡重置功能異常', 'error');
                }

            } catch (e) {
                log(`✗ 測試失敗: ${e.message}`, 'error');
            } finally {
                // 恢復原始狀態
                PlayerManager.state = originalState;
                PlayerManager._saveState = originalSave;
                log('✓ 已恢復 PlayerManager 原始狀態', 'info');
            }
        });

        // 測試侍女自動合成
        document.getElementById('testMaidSystem').addEventListener('click', async () => {
            if (!buildingManager || !resourceManager) {
                log('✗ 管理器未初始化', 'error');
                return;
            }

            log('\n=== 測試侍女自動合成 ===', 'info');

            // 1. 設置侍女建築
            const maid = buildingManager.getBuilding('maid');
            if (maid) {
                maid.level = 1;
                log('✓ 已將侍女等級設為 1', 'success');
            } else {
                log('✗ 找不到侍女建築', 'error');
                return;
            }

            // 2. 設置資源與合成目標
            const targetRes = 'stone_mid'; // 中品靈石
            const recipe = { 'stone_low': 5, 'lingli': 10 }; // 假設配方

            // 確保有足夠材料
            const stoneLow = resourceManager.getResource('stone_low');
            const lingli = resourceManager.getResource('lingli');
            const stoneMid = resourceManager.getResource('stone_mid');

            stoneLow.value = 100;
            lingli.value = 1000;
            stoneMid.value = 0;

            log(`初始材料: 下品靈石=${stoneLow.value}, 靈力=${lingli.value}`, 'info');
            log(`目標產物: 中品靈石=${stoneMid.value}`, 'info');

            // 確保目標資源已解鎖 (craft 方法會檢查 unlocked)
            if (!stoneMid.unlocked) {
                resourceManager.unlockResource(targetRes);
                log(`✓ 已手動解鎖 ${targetRes}`, 'info');
            }

            // 3. 啟用自動合成
            buildingManager.maidAutoTargets[targetRes] = true;
            log(`✓ 已啟用 ${targetRes} 的自動合成`, 'success');

            // 4. 執行自動合成邏輯
            log('執行 runMaidWork()...', 'info');
            buildingManager.runMaidWork();

            // 5. 驗證結果
            // 由於 runMaidWork 每次只合成一個，所以產物應該增加 1
            const success = stoneMid.value === 1;
            log(`合成後: 下品靈石=${stoneLow.value}, 靈力=${lingli.value}`, 'info');
            log(`產物數量: ${stoneMid.value}`, success ? 'success' : 'error');

            if (success) {
                log('✓ 侍女自動合成功能正常', 'success');
            } else {
                log('✗ 侍女自動合成失敗', 'error');
            }

            // 清理狀態
            maid.level = 0;
            buildingManager.maidAutoTargets[targetRes] = false;
        });

        // 測試修煉時間顯示
        document.getElementById('testTrainingTime').addEventListener('click', async () => {
            log('\n=== 測試修煉時間顯示 ===', 'info');
            const { default: EraManager } = await import('./src/utils/EraManager.js');
            const { default: LanguageManager } = await import('./src/utils/LanguageManager.js');

            if (!EraManager.isLoaded) await EraManager.init();
            await LanguageManager.getInstance().init();

            // Force zh-CN to ensure text matching
            await LanguageManager.getInstance().loadLanguage('zh-CN');

            const mockEraId = 1;
            const mockLevel = 1;
            const requiredTime = EraManager.getLevelUpRequiredTime(mockEraId, mockLevel); // Seconds

            log(`等級 1 所需總時間: ${requiredTime} 秒`, 'info');

            // Case 1: 0 經驗
            let trainingTime = 0;
            let result = EraManager.checkLevelUpRequirements(mockEraId, mockLevel, trainingTime, [], {});
            log(`修練時間 0秒 -> 提示: ${result.reason}`, 'info');

            // 檢查是否顯示為剩餘時間 (總時間)
            // 0 經驗時，剩餘時間 = 總時間
            const totalInSi = (requiredTime / 60).toFixed(2);
            if (result.reason.includes(totalInSi)) {
                log(`✓ (0經驗)數值正確: ${totalInSi}`, 'success');
            } else {
                log(`✗ (0經驗)數值錯誤`, 'error');
            }

            // Case 2: 已修練一半時間
            trainingTime = requiredTime / 2;
            result = EraManager.checkLevelUpRequirements(mockEraId, mockLevel, trainingTime, [], {});
            log(`修練時間 ${trainingTime}秒 -> 提示: ${result.reason}`, 'info');

            const remainingInSi = ((requiredTime - trainingTime) / 60).toFixed(2);
            if (result.reason.includes(remainingInSi)) {
                log(`✓ (50%經驗)數值正確: ${remainingInSi} (顯示剩餘而非總需)`, 'success');
            } else {
                log(`✗ (50%經驗)數值錯誤. 預期包含: ${remainingInSi}`, 'error');
            }

            // Case 3: 檢查是否有 "還需" 字樣
            if (result.reason.includes('还需') || result.reason.includes('還需')) {
                log('✓ 包含 "还需/還需" 字樣', 'success');
            } else {
                log(`✗ 缺少 "还需" 字樣`, 'error');
            }
        });

        // 測試提示系統狀態
        document.getElementById('testHintSystem').addEventListener('click', async () => {
            log('\n=== 測試提示系統狀態 ===', 'info');
            const { default: PlayerManager } = await import('./src/utils/PlayerManager.js');

            // 1. Check if shownEraHints exists in default state
            const hints = PlayerManager.getHints();
            log(`Hints State: ${JSON.stringify(hints)}`, 'info');

            if (Array.isArray(hints.shownEraHints)) {
                log('✓ shownEraHints array exists', 'success');
            } else {
                log('✗ shownEraHints is missing or not an array', 'error');
            }

            // 2. Mock adding a hint
            const mockEraId = 99;
            const currentShown = hints.shownEraHints || [];
            if (!currentShown.includes(mockEraId)) {
                const newShown = [...currentShown, mockEraId];
                PlayerManager.updateHints({ shownEraHints: newShown });

                const updatedHints = PlayerManager.getHints();
                log(`Updated Hints: ${JSON.stringify(updatedHints)}`, 'info');

                if (updatedHints.shownEraHints.includes(mockEraId)) {
                    log('✓ Hint state updated successfully', 'success');
                } else {
                    log('✗ Failed to update hint state', 'error');
                }

                // Cleanup (optional, but good for repetitive testing)
                const cleanupShown = newShown.filter(id => id !== mockEraId);
                PlayerManager.updateHints({ shownEraHints: cleanupShown });
            } else {
                log('✓ Mock hint already exists (skipping update test)', 'info');
            }
        });

        // --- 宗門系統測試邏輯 ---
        let SectManager = null;

        // Lazy load SectManager manually for tests if not global
        async function getSectManager() {
            if (SectManager) return SectManager;
            const { default: sm } = await import('./src/utils/SectManager.js');
            SectManager = sm;
            return SectManager;
        }

        document.getElementById('sectCheckUnlock').addEventListener('click', async () => {
            log('\n=== 宗門解鎖測試 ===', 'info');
            const { default: PlayerManager } = await import('./src/utils/PlayerManager.js');

            // Set Era to 2
            PlayerManager.state.eraId = 2;
            log('已將境界設為 2 (築基期)', 'info');

            // Check logic (MainView visibility logic mock)
            if (PlayerManager.getEraId() >= 2) {
                log('✓ 解鎖條件檢查通過: Era >= 2', 'success');
            } else {
                log('✗ 解鎖條件檢查失敗', 'error');
            }
        });

        document.getElementById('sectAddRes').addEventListener('click', async () => {
            if (!resourceManager) return log('✗ 資源管理器未初始化', 'error');

            // Add basic resources for contribution (Era 2 cost)
            // Era 2 cost: stone_low: 100, wood: 100
            const resList = ['stone_low', 'wood', 'spirit_grass_low'];
            resList.forEach(id => {
                const res = resourceManager.getResource(id);
                if (res) {
                    res.unlocked = true;
                    res.value += 1000;
                    log(`已添加 ${id}: +1000 (當前: ${res.value})`, 'info');
                }
            });

            // Unlock lingli just in case
            const lingli = resourceManager.getResource('lingli');
            if (lingli) { lingli.unlocked = true; lingli.value = 10000; }
        });

        document.getElementById('sectContribute').addEventListener('click', async () => {
            const sm = await getSectManager();
            const { default: PlayerManager } = await import('./src/utils/PlayerManager.js');

            log('\n=== 宗門貢獻測試 ===', 'info');

            // Ensure window.game is set (fix for undefined error)
            if (!window.game || !window.game.resourceManager) {
                log('修復 window.game 參考...', 'info');
                window.game = window.game || {};
                window.game.resourceManager = resourceManager;
                window.game.buildingManager = buildingManager;
                window.game.uiManager = { addLog: (msg, type) => log(`[GameLog] ${msg}`, type || 'info') };
            }

            // Force active contribution count for test
            sm.state.contributionCount = 3;
            log(`重置今日貢獻次數為: ${sm.state.contributionCount}`, 'info');

            // Mock Player Era if needed (ensure Era 2 for low cost)
            if (PlayerManager.getEraId() < 2) PlayerManager.state.eraId = 2;

            const beforeDev = sm.state.developmentPoints;
            const result = sm.contribute();

            if (result.success) {
                log(`✓ 貢獻成功!`, 'success');
                log(`發展度: ${beforeDev} -> ${sm.state.developmentPoints}`, 'info');
                log(`剩餘次數: ${sm.state.contributionCount}`, 'info');
            } else {
                log(`✗ 貢獻失敗: ${result.msg}`, 'error');
            }
        });

        document.getElementById('sectMaxLevel').addEventListener('click', async () => {
            const sm = await getSectManager();
            sm.state.sectLevel = 5;
            sm.state.developmentPoints = 999;
            log('✓ 已將宗門設為 LV5 (滿級)', 'success');
        });

        document.getElementById('sectTaskTest').addEventListener('click', async () => {
            const sm = await getSectManager();
            log('\n=== 宗門任務測試 ===', 'info');

            // 1. Refresh
            if (sm.refreshTasks) sm.refreshTasks();
            else if (sm.default && sm.default.refreshTasks) sm.default.refreshTasks();
            log('1. 已刷新任務列表', 'info');
            if (sm.state.tasks.length > 0) {
                log(`生成了 ${sm.state.tasks.length} 個任務`, 'success');
                const task = sm.state.tasks[0];
                log(`> 任務0: ${task.name} (時間: ${task.duration / 1000}s)`, 'info');

                // 2. Start Task
                // Force 5 seconds duration for test
                task.duration = 5000;
                const startRes = sm.startTask(0);
                if (startRes.success) {
                    log(`2. 任務開始成功 (測試修改時長為 5s)`, 'success');

                    // 3. Wait/Simulate
                    log('...模擬等待 5秒...', 'info');
                    // Manually set start time to past
                    sm.state.activeTask.startTime = Date.now() - 6000;

                    // 4. Claim
                    const claimRes = sm.claimTaskReward();
                    if (claimRes.success) {
                        log(`3. 獎勵領取成功! 獲得: ${JSON.stringify(claimRes.rewards)}`, 'success');
                    } else {
                        log(`✗ 領取失敗: ${claimRes.msg}`, 'error');
                    }
                } else {
                    log(`✗ 任務開始失敗: ${startRes.msg}`, 'error');
                }
            } else {
                log('✗ 任務列表為空', 'error');
            }
        });

        // 存檔系統測試
        document.getElementById('testSaveCode').addEventListener('click', () => {
            try {
                log('開始生成存檔碼...', 'info');
                if (!SaveSystem) {
                    log('✗ SaveSystem 類別未載入，請檢查 init() 是否成功', 'error');
                    return;
                }
                if (!resourceManager || !buildingManager) {
                    log('✗ 管理器未初始化', 'error');
                    return;
                }

                log('實例化 SaveSystem...', 'info');
                const saveSystem = new SaveSystem({ resourceManager, buildingManager });

                log('調用 generateSaveCode()...', 'info');
                const code = saveSystem.generateSaveCode();

                if (!code) {
                    log('✗ 生成的存檔碼為空 (可能有錯誤在 Console)', 'error');
                } else {
                    document.getElementById('saveCodeArea').value = code;
                    log('✓ 已生成存檔碼，長度: ' + code.length, 'success');
                }
            } catch (err) {
                log(`✗ 執行崩潰: ${err.message}`, 'error');
                log(err.stack, 'error');
                console.error(err);
            }
        });

        document.getElementById('testLoadCode').addEventListener('click', async () => {
            const code = document.getElementById('saveCodeArea').value;
            if (!code) return log('✗ 請提供存檔碼', 'error');
            const saveSystem = new SaveSystem({ resourceManager, buildingManager });
            const data = saveSystem.parseSaveCode(code);
            if (data) {
                const { default: PlayerManager } = await import('./src/utils/PlayerManager.js');
                log('解析成功，正在載入數據...', 'info');
                if (data.player) PlayerManager.loadData(data.player);
                resourceManager.loadData(data.resources);
                buildingManager.loadData(data.buildings);
                log('✓ 存檔碼讀取完成', 'success');
            } else {
                log('✗ 存檔碼無效', 'error');
            }
        });

        document.getElementById('testSaveStorage').addEventListener('click', () => {
            if (!resourceManager || !buildingManager) return log('✗ 管理器未初始化', 'error');
            const saveSystem = new SaveSystem({ resourceManager, buildingManager });
            saveSystem.saveToStorage();
            log('✓ 已保存至 Storage', 'success');
        });

        document.getElementById('testLoadStorage').addEventListener('click', async () => {
            if (!resourceManager || !buildingManager) return log('✗ 管理器未初始化', 'error');
            const saveSystem = new SaveSystem({ resourceManager, buildingManager });
            const data = saveSystem.loadFromStorage();
            if (data) {
                const { default: PlayerManager } = await import('./src/utils/PlayerManager.js');
                if (data.player) PlayerManager.loadData(data.player);
                resourceManager.loadData(data.resources);
                buildingManager.loadData(data.buildings);
                log('✓ 從 Storage 讀取完成', 'success');
            } else {
                log('✗ Storage 中無存檔', 'error');
            }
        });

        // 自動初始化
        init();
    </script>
</body>

</html>